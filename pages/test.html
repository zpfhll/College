<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <script src="vue.js" type="text/javascript" charset="utf-8"></script>
        <script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>

    </head>
    <body>
       
        <div id="lifeCycle" v-if="show">
            <p>-------生命周期---------</p>
            {{message}} <br/>
            <li v-for="life in lifeCycle">{{life.content}}</li>
            <button v-on:click='click'>終了</button>
        </div>

       
        <div id="computed">
            <p>-------计算属性和侦听器---------</p>
            {{fullName}} <br/> <!-- 调用计算属性 -->
            {{fullName}} <br/> <!-- 依赖没有发生改变，所以不会调用计算属性 -->
            {{fullNameFunc()}}<br/> <!-- 无论依赖有没有变化，都会调用方法 -->
            {{fullNameFunc()}}<br/> <!-- 无论依赖有没有变化，都会调用方法 -->
            {{ firstName }} + {{lastName}}</br>
            <input v-model="sendMessage">
            <button v-on:click="onClick">設定</button>
            {{ message }}
        </div>

        <script type="text/javascript" charset="utf-8">
                var lifeData = {
                    message: "生命周期",
                    lifeCycle: [{content: "start new"}],
                    show: true
                }
                var vm = new Vue({
                    el: '#lifeCycle',
                    data: lifeData,
                    methods: {
                        click: function() {
                            this.message = "end"
                        }
                    },
                    beforeCreate: function() {
                        lifeData.lifeCycle.push({content: "beforeCreate-> el: " + this.$el + " \\ data: " + this.$data})
                    },
                    created: function() {
                        lifeData.lifeCycle.push({content: "created-> el: " + this.$el + " \\ data: " + this.$data})
                    },
                    beforeMount: function() { //虚拟的el
                        lifeData.lifeCycle.push({content: "beforeMount-> el: " + this.$el + " \\ data: " + this.$data})
                    },
                    mounted: function() {
                        lifeData.lifeCycle.push({content: "mounted-> el: " + this.$el + " \\ data: " + this.$data})
                    },
                    beforeUpdate: function() {//数据被更新，但视图还未被更新
                        console.log("beforeUpdate-> el: " + this.$el + " \\ data: " + this.$data.message)
                    },
                    updated: function() {
                        console.log("updated-> el: " + this.$el + " \\ data: " + this.$data.message)
                    },
                    beforeDestroy: function() {
                        data.lifeCycle.push({content: "beforeDestroy-> el: " + this.$el + " \\ data: " + this.$data})
                    },
                    destroyed: function() {
                        data.lifeCycle.push({content: "destroyed-> el: " + this.$el + " \\ data: " + this.$data})
                    }
                })
                // vm.$mount('#title')
                vm.show = false


                //-----
                var computeData = {
                    firstName: "赵",
                    lastName: "泽骐",
                    message:"",
                    sendMessage:""
                }
                var tag = "start"
                var computeVue = new Vue({
                    el: "#computed",
                    data: computeData,
                    computed: {//计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值
                        fullName: {
                            get: function() {
                                console.log("computed: " + tag + "->" + this.firstName + " " + this.lastName)
                                return this.firstName + " " + this.lastName
                            },
                            set: function(newValue) {
                                var names = newValue.split(' ')
                                this.firstName = names[0]
                                this.lastName = names[names.length - 1]
                            }   
                        } 
                    },
                    methods: {
                        fullNameFunc: function() {
                            console.log("methods: " + tag + "->" + this.firstName + " " + this.lastName)
                            return this.firstName + " " + this.lastName
                        },
                        onClick: function() {
                            this.fullName = '赵 麦穗'
                            var vm = this
                            axios.get('http://192.168.18.6:8080/test?name=' + this.sendMessage)
                                .then(function (response) {
                                    vm.message = response.data
                                })
                                .catch(function (error) {
                                    vm.message = 'Error! Could not reach the API. ' + error
                                })
                        }
                    },
                    watch: {
                        sendMessage: function(newValue, oldValue) {
                            console.log("oldValue: " + oldValue + "->  newValue:" + newValue)
                        }
                    }
                }) 
                tag = "seting"
                computeData.firstName = "赵" // 值没有变化，或者不是最后一次，不会再调用计算属性从新计算，也不会调用方法
                computeData.firstName = "韩" // 值有所变化，但不是最后一次，不会调用计算属性，也不会调用方法
                computeData.firstName = "宋" // 值有所变化，并且是最后一次，所以会再调用计算属性，也会调用方法 并且绑定的方法被注册了几次，此时也会被再次调用几次，而计算属性只会被调用一次
                
        </script>
    </body>
</html>
